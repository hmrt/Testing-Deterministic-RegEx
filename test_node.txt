
node1 = Node('disj','1','+')
node2 = Node('atom','11','a')
node3 = Node('star','12','*')
node4 = Node('atom','121','b')
k = node1.get_right()
print "Tree from k:"
print k.print_tree()
print
print "Root: "+k.get_root().symbol
print
print "Tree:"
print k.get_root().print_tree()
print
print "Reg.Exp? "+str(get_root().check_reex())

#################################################
################ LEMMA 2.6 ######################
#################################################

# epsilon acceptance by lemma 2.6
def ewp_SupFirst(p,q):
    node = pSupFirst(q)
    if len(node.path) == 1 or p.type != position or q.type != position or not follow(p,q):
        return False
    node = node.get_parent()
    if node.reflexive(pSupLast(p)):
        return True
    return False


##################################################

NT = {}
kkk = str2regexp("(a*(b(a*)b(a*))*(a(aa+b*bbb*)*)*)*")
kkk = kkk.marked()
eTree(kkk,"1")
print kkk.followListsD()
print followList()

#################################################

a = str2regexp("a(b+cd)*")
a = a.marked()
NT = {}
eTree(a,"1")
p = NT.get("11") # atom(a)
q = NT.get("12") # star(b+cd)
q1 = NT.get("1211") # atom(b)
q2 = NT.get("12121") # atom(c)
q3 = NT.get("12122") # atom(d)
print "atom(a) is followed by atom(b): %s"%follow(p,q1)
print "atom(a) is followed by atom(c): %s"%follow(p,q2)
print "atom(a) is followed by atom(d): %s"%follow(p,q3)
print "atom(a) is followed by:",p.followList()
print "star(b+cd) first:",q.first()
print "star(b+cd) last:",q.last()

#################################################
########## CRIAR RANDOM REGEXP ##################
#################################################

from FAdo.cfg import *
from FAdo.fa import *
op = reStringRGenerator(Sigma=["a","b"], size=1000, cfgr=reGrammar["g_rpn"], epsilon=None, empty=None)
# cProfile.run()
l = op.generate()
r = str2regexp(l,parser=ParserRPN).reduced()
marked = r.marked()
NT = {}
eTree(marked,"1")


#################################################
########## check if it's correct ################
#################################################

def f():
    d = marked.followListsD()
    k = followList()
    for x in d:
        if set(d[x]) != k[x]:
            print d[x],"...",k[x]
            return False
    return True
print f()

#################################################
############## eTree structure ##################
#################################################

"""
Node* node;
union{
    void none;
    struct eTree* son;
    struct{
        struct eTree* son1;
        struct eTree* son2;
    }
}
"""

##################################################
########## check if it's correct ################
#################################################

-> criar class TREE;
-> BuildNext();
-> otimizar followList
